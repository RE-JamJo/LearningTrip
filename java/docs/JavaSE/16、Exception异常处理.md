# Exception

## 基本概念

### 狭义的异常

- 简单来说异常就是用来表示Java程序运行过程中的错误(信息) 

### 异常机制

- java语言程序，获取程序运行过程中的错误，并处理错误的机制

### 异常机制的由来

- C语言时代的错误处理，紧靠口头的约定，没有任何语法的强制约束
- Java的基本理念: 将错误尽可能的摒弃在jvm之外，所以在代码编译时做了很多额外的，代码检查工作
- 但是并非所有的错误都能在编译代码的时候处理，这意味着程序运行的时候，也会发生一些错误，因此，java语言提供了一种统一的方式(机制)，让程序自己在出错的时候，自己处理这些错误，即一种程序运行时的错误恢复机制

### 异常机制的本质

- 提供了一种一致性的错误报告模型
- 使得类的构建者和使用者之间可以进行可靠的沟通 

### 异常的分类(根据错误的严重程度)

- Error

	- 十分严重，已经不是软件层面可以解决的了，所以我们处理不了，也不关心

- Exception

	- 严重程度，没有那么严重，我们自己或许可以处理
	- 分类：编译时异常CheckableException，运行时异常RuntimeException

### 常见异常

- 空指针异常
- 数组越界异常

## JVM的默认异常处理

- 当我们代码在执行到，发生错误的地方，jvm就会首先终止我们自己程序的运行，转而执行jvm自己的错误处理流程

- 在发生错误地方，收集错误信息，产生一个描述错误的对象

- 描述此次错误的异常对象，将错误信息，输出到控制台窗口中

## JAVA语言提供的，java程序自己的异常处理

### 利用try-catch代码块

- 当我们写在，try代码块中的代码，出现异常的的时候该异常的信息会被jvm收集起来，并交给我们自己的异常处理器，
- 每一个catch分支就是一个异常处理器
- 这个过程我们称之为异常的捕获

### 单分支的异常处理

- 如果try中代码，运行时，发生了错误，jvm在发生错误的代码处，收集错误信息
- try 块中在错误代码之后的代码，就不会在运行，jvm跳转到，相应的错误处理器中，执行有开发者，自己写的，错误处理代码
- 错误处理器中的代码，一旦执行完毕，紧接着程序继续向下正常执行，执行的是整个try代码块之后的代码

### 多分支的异常处理

- 原因

	- 在一个try块中，可能出现多种类型的异常,如果只有一个catch分支(一个异常处理器)，也就是说，所有类型的异常都会交给这个异常处理器来处理，但通常可能不同类型的异常，错误处理的方式不同，
	- 因此，我们需要对同一个try块，针对可能发生的多种类型的错误，定义多种类型的异常处理器，即多种类型的catch分支，针对不同类型的异常，做不同的处理

- 多分支异常匹配过程

	- jvm 怎么知道，把异常对象交给哪个异常分支，并执行那个异常分支中的代码，这就存在一个多分支异常处理的匹配问题：
	- 1.根据实际的异常对象的类型，和异常分支(异常处理器)声明的异常类型，从上到下一次做类型匹配
	- 2.一旦通过类型匹配，发现实际异常对象的类型和Catch分支(异常处理器)声明的异常类型，类型匹配，就把异常对象交给这个异常分支（异常处理器）处理
	- 3.多分支的异常处理的执行，有点类似于多分支if-else的执行，一次匹配，只会执行多个catch分支中的一个

- 注意事项

	- 1.如果说，在多catch分支的情况下，如果不同的catch分支，处理的异常类型，有父子关系那么就一定要注意，处理子类的异常分支写在前面，父类的异常分支写在后面
	- 2.不是包裹在try块中的代码，一旦产生了异常，都是自己来处理，只有try中异常类型，有对应类型的异常处理器的时候

## 获取异常信息

- getMessage() 获取异常描述信息，返回字符串。 

- toString()获取异常类名和异常信息，返回字符串。 

- printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置,并打印到控制台

## 编译时异常VS运行时异常

- 运行时异常 无需显示处理，也可以和编译时异常一样处理

- Java程序必须在写代码时显示处理，否则程序就会发生错误无法通过编译 

- 空指针异常，数组越界异常，除0异常 它们其实都是运行时异常

## 异常的抛出

### throws

- 作用

	- 其语法约束，主要针对的是编译时异常:
	- 1.在方法定义时使用
	- 2.声明该方法可能抛出的异常(throws后面，跟一个异常列表)
	- 3.对于编译时异常 ，可以在语法层面个强制方法调用者处理该异常

- 语法

	- 修饰符  返回值(形参列表)  throws 异常列表 {}

#### 注意事项

- 注意事项1

    - 对于运行时异常而言，jvm在其发生异常的时候，会自动，将异常信息，向上抛出(抛出给方法调用者)
    - 但是，对于编译时异常而言，只有在方发声明中，用throws关键字声明过，可能抛出的编译时异常，此时，这些被throws关键字声明的编译时异常，当实际发生的时候，才可以向上抛出

- 注意事项2

    - 异常列表之间用逗号分割，列表中出现的异常不要出现包含关系

- 注意事项3

    - 方法覆盖时的子类异常列表必须与父类兼容(有关方法覆盖)

    - 如果父类方法中没有声明抛出编译时异常，如果要覆盖父类方法，子类也不能有编译时异常的异常列表；但是对于运行时异常，没有此要求
    - 对于编译时异常，子类的异常列表可以和父类一模一样，也可以不一样，但不一样的时候要保证，子类中方法的异常列表中的异常类型，必须是父类异常列表中异常， 的子类类型; 但是对于运行时异常，没有此要求

- 子父类抛出异常保持一致

### throw

- 作用

	- 1. 在方法体中使用
	- 2. 主动在程序中抛出异常(真正的自己抛出动作，throw)
	- 3. 每次只能抛出确定的某个异常对象

- 执行特征

	- 一旦执行了throw关键字的抛出异常对象语句，代码的执行，直接跳转到上一层(方法调用处)

- 基本语法

	- throw 异常对象

- 注意事项

	- 若要抛出 编译时异常 ， 则必须和throws配合起来使用

### 、throws VS throw

- throws用在方法声明后面，跟的是异常类名 ;throw 用在方法体内，跟的是异常对象名 
- throws 可以跟多个异常类名，用逗号隔开 ;throw一次只能抛出一个异常对象 
- throws 表示抛出异常，由该方法的调用者来处理 ;表示抛出异常，可以由方法体内的语句处理 
- throws throws表示出现异常的一种可能性，并不一定会发生这些异常 throw则是抛出了异常，执行throw则一定抛出了某种异常 

## 异常处理的总结

### 我们所学习过的异常的处理策略主要有两种 

- 捕获并处理 
- 向上抛出 

### 异常处理的原则

- 如果该功能内部可以将问题处理用try,-catch
- 如果处理不了,交由调用者处理用throws

### 异常一旦被捕获，并且没有再次被抛出，那么上层是感知不到该异常的！！！！ 

## finally

### 执行特征

- 被finally控制的语句体一定会执行 
- 特殊情况：在执行到finally之前jvm退出了(比如System.exit(0)) 

### 作用

- 用于释放资源，在IO流操作和数据库操作中会见到 

### final、finally、finalize

- final

	- 修饰类、成员变量、成员方法

- finally

	- 异常处理体系中，用于资源释放，最大特点（不发生特殊情况，必然会执行）

- finalize

	- Object()类中的成员方法，垃圾回收

## 自定义异常

- 很多情况下，jdk并没有提供现成的异常类，来描述我们自己特定应用场景下的异常情况，因此很多时候，我们需要自己定义异常来描述我们自己特定应用场景下的异常情况

### 实现

- 继承自Exception 

	- 编译时要检查

- 继承自RuntimeException 

	- 编译时不需要检查

