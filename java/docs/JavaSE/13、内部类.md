## 内部类

### 概念

- 定义在其他类内部的类就称为内部类 

### 访问特征

- 内部类可以直接访问外部类的成员，包括私有。（此处外部类是指包含内部类的类）
- 外部类要访问内部类的成员，必须创建对象。 

### 分类

按照内部类在类中定义的位置不同，分为成员位置内部类、局部位置内部类、匿名内部类对象。

#### 成员位置内部类

- 定义在类中，方法体之外，可以看做是外部类的一个普通成员，这意味着，内部类依赖于外部类对象而存在。

- 创建内部类对象（即如何访问到内部类）

    - 外部类中，和创建普通类对象没啥区别
    - 外部类的外部，通过`外部类名.内部类名`访问，比如`对象名 = 外部类对象.内部类对象`

- 成员内部类常用修饰符

    - private保证成员位置内部类只对其外部类可见。

    - static整个内部类，就变成了一个静态上下文，内部类不再依赖于外部类对象而存在。

#### 局部位置内部类

- 定义在类中的，方法体内

- 局部内部类，只能在定义内部类的方法体中创建该内部类对象

- 局部内部类的访问特征

    - 局部内部类除了有所有内部类共有的访问特征之外，还有一个特征就是，局部内部类可以访问方法体中的局部变量
    - 但是局部内部类只能访问final的局部变量
    - 定义在方法中的局部变量，没有被final修饰且仅赋值一次时，默认为final

- 产生这种访问特征的原因

    - 核心原因生命周期的冲突问题
    - 局部变量存储在栈帧中，栈帧随方法执行的结束，而被销毁
    - 而局部内部类对象并不一定随着方法的执行而被销毁
    - 即方法执行结束后，局部变量已经不存在，而匿名内部内对象，还活着，因此它就可以去访问那个已经不存在的局部变量

#### 匿名内部类对象

- 本质：是一个匿名（继承了类或者实现了接口的 匿名子类)对象


- 优点

    - 不管是成员或局部位置内部类，我们要使用内部类都分成了2步：定义内部类，创建内部类对象。
    - 而通过定义匿名内部类对象，我们可以将上面的2步变为1步。

- 前提条件

    - 存在一个类或者接口，这里的类可以是具体类也可以是抽象类。

- 语法

    - `new 类名或者接口名() {重写方法;};`

- 匿名内部类对象成员的访问

    - 一个匿名内部类对象，因为是个匿名对象，所以每访问一次成员，都需要创建一个对象(除非用一个引用变量指向该对象)。
    - 即只能在创建匿名对象时候访问匿名对象一次，且仅一次。
    - 这与jvm的GC（垃圾回收器）机制有关，当没有其他引用变量指向这个对象时，这个对象会被标记为垃圾回收。

- **两种使用场景**

- `new 类名或者接口名() {重写方法;}.方法;`只使用某抽象类，或者接口子类对象一次的情况下使用

    - 方法的形式参数，是引用类型的情况重点是接口的情况
    - 方法返回一个接口类型的子类对象的时候

- `类名或者接口名 命名 = new 类名或者接口名() {重写方法;};`再通过`命名.方法;`来使用，也可以用一个引用变量，指向一个匿名内部类对象

    - 相当于多态，但是不能调用子类中单独定义的方法
