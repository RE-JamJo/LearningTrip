## 面向对象特殊语法

### 成员变量  VS 局部变量

- 定义的位置不同：成员变量定义在方法体之外，局部变量定义在类体中或者是方法的形式参数
- 内存位置不同：成员变量的值存储在堆上，局部变量的值在栈上
- 声明周期不同：成员变量的存储空间随对象的销毁而销毁，局部变量随方法栈帧的销毁而销毁
- 初始值不同: 局部变量没有被自动赋予默认初值，而成员变量会有默认初值认


### 方法引用类型的形式参数

- 实参和形参的值传递方式，是复制传递
- 引用类型的变量，在调用方法，和被调用方法中，都属于各自方法中定义的局部变量
- 引用类型的实参和形参的值，在调用方法和被调用方法中各自都有一份
- 但是，引用类型的实参和形参所指向的数据，是同一份数据

### 构造方法

与普通方法相区别开来。

作用：在创建对象的时候，完成对象成员变量的初始化工作。

如何完成对象成员变量初始化：

	- 构造方法，可以接收参数，可以利用接受到的参数值，来初始化对象成员变量的初始值
	- 在构造方法的方法体中，我们自己通过赋值语句，来完成对对象的赋值

#### 语法：

-  方法名固定，必须和类名相同

    - 所以构造方法的名字违反了驼峰命名规则，这是Java语言规定的

- 方法声明中，没有返回值类型这一项
- 其他和普通的方法定义类似
```java
class Example {
	int a;
	public Example(int b) { //构造方法
	a = b;
	}
}
```

#### 注意事项

- 构造方法可以重载

	- 重载条件和普通方法的重载条件相同
	- 可以根据new 类名(实参列表)中的实参列表指明创建某对象时所使用的构造方法

- 如果没有定义任何构造方法，则jvm会自动帮我们添加一个默认构造方法，否则，不会。

- 构造方法的执行时机: 在创建对象的最后一步才会执行，jvm用来初始化对象中成员变量的值
- 如果想开辟内存空间，只能依靠关键字new来进行开辟。

	- 即：只要看到关键字new不管何种情况下，都表示要开辟新的内存空间。

### this

this关键字表示当前对象自身的引用。

如何确定this指的是哪个对象？

- 如果this出现在，构造方法中，指的是正在创建的那个对象
- 如果this出现在成员方法中，因为成员方法总是以对象名. 的方式访问，使用对象访问该方法，this就指的是哪个对象

调用构造方法的this只能出现在构造方法中，且只能在第一行。

普通成员方法的方法体中，不能利用this调用。

this的作用：

- 解决成员变量的隐藏问题
- 访问对象的成员变量和成员方法
- 访问对象的构造方法
    this(参数1, 参数2, 参数3)
```java
public class Demo1 {
	public static void main(String[] args) {
		int a = 10;
		int b = 20;
        Add n = new Add(a, b);
        n.printSum;
	}
}
//创建Add类
class Add {
	//对象属性
	int a;
	int b;
	
	//默认无参构造方法，一旦自行创建构造方法，该方法就被覆盖了
	//public Add() { };
	public Add(int a, int b) {
		this.a = a;
		this.b = b;
	}
	//对象行为
	public void printSum() {
		System.out.println(this.a + this.b);
	}
}
```

### static

#### 使用

static关键字：特点是被该类的所有对象所共享(判定是否使用static的关键)。

- 一旦一个普通成员变量被static修饰，该成员变量就称之为静态成员变量（静态变量）

    - 该成员变量就不再储存于对象中了，而是单独储存一份，被该类所有成员共享

- 一旦一个普通成员方法被static修饰，该成员方法就称之为静态成员方法（静态方法），即跟普通方法没什么区别。

- 可以直接通过类名访问static修饰的成员变量和成员方法

	- 只有静态成员能用类名.来访问（官方推荐）
	- 普通非静态成员只能用对象名.来访问

#### 执行时机

随着类加载而加载。

- static修饰的成员变量，类加载时在方法区分配存储空间，并赋予默认初值
- static修饰的成员方法，类加载完毕，就可以通过类名访问

- 优先于对象而存在

- 当我们首次访问，类的静态成员变量或者静态成员方法的时候，此时，会触发类的加载。
即任何时候都可以访问，不依赖对象而存在。

#### 注意事项

- 静态方法中不能访问非静态的成员变量和非静态的成员方法
- 静态方法中不能使用this
- 不管静态方法还是非静态方法中，都不能使用static关键字，即static关键字不能使用在方法体中。

#### 被static修饰的成员的存储位置

被static修饰的成员的存储在方法区中。

#### static使用场景

- 当我们希望，某个成员变量的值，被该类的所有对象所共享，此时可以使用static修饰这个成员变量
- 通常当我们需要定义一个方便被别人使用工具方法的时候，此时将该方法定义成静态方法

#### 静态成员变量 VS 普通成员变量

- 所属不同

	- 静态变量属于类，所以也称为类变量
	- 成员变量属于对象，所以也称为实例变量

- 内存中的位置不同

	- 静态变量储存于方法区
	- 成员变量储存于堆内存

- 内存中出现的时间不同

	- 静态变量随着类的加载而加载，随着类的消失而消失
	- 成员变量随着对象的创建而存在，随着对象的消失而消失

- 访问方式不同

	- 静态变量可以通过类名调用，也可以通过对象调用
	- 成员按量只能通过对象名调用

### 代码块codeblock

#### 定义

- 在Java中，使用{}括起来的代码被称为代码块

- 在嵌套的代码块中，不能定义同名的局部变量

#### 局部代码块

- 定义位置：定义在方法体中，通常开发中没人用
- 执行时机：随着所在方法的执行而执行
- 优点：限定局部变量生命周期，及早释放，提高内存利用率（但是该效果可以忽略不记，且极难维护，所以实际开发不要使用）。

#### 构造代码块

- 定义位置：定义在类中方法体之外

- 执行时机：每次创建对象的时候必执行，而且先于构造方法执行。

	- 可以用来创建对象时给成员变量赋初值
	- 构造代码块和成员变量的初始化语句执行先后顺序取决于定义的先后顺序（通常实际开发中初始化语句写在前面）。


到目前为止，我们有3种方式给一个成员变量赋初值：成员变量的初始化语句、构造代码块、构造方法。

- 使用场景

	- 可以利用构造代码块，在构造代码块中，访问成员变量，在创建成员变量的时候给该成员变量赋初值
	- 多个构造方法中都需要执行一段相同的代码，我们就可以把这些代码放在构造代码块中

- 注意事项

	- 如果有多个构造代码块，则这多个构造代码块，按照书写的先后顺序执行

#### 静态代码块

- 定义位置：类中方法体之外，但同时代码块被static关键字修饰

- 执行时机：随类加载而执行（只要类加载，静态代码块就会执行）。

- 注意事项

	- 静态代码块，属于静态上下文，在静态代码块中，不能访问非静态的成员变量和成员方法
	- 因为随着类加载而加载，所以在同一个jvm中，只会执行一次（因为一个类只会被一个jvm最多加载一次）。

- 使用场景

	- 当代码在整个程序运行过程中只需要执行一次，这样的代码我们就可以放在静态代码块中

#### 同步代码块(多线程的时候学习)

### package关键字

- 定义位置：在Java源程序文件的第一行使用package声明可以使文件中定义的类成为指定包的成员。
	
    - 虽然，在Java文件中，我们可以不使用package关键字来声明一个Java文件中定义的类所属的包，但这不意味着这个类不属于某个包，没有显示使用package关键字声明其所属包的类，都属于Java语言中的默认包。
- 作用

	- 类比于操作系统中用来组织文件的文件夹，java语言中，用包来组织类
	- 包还可以用来解决，类的同名问题，不同包下可以存在同名类

- 语法：`package 包名;`

	- package 关键在后跟包名，且这条语句必须放在java文件第一条语句的位置

- 包的命名方式：域名反转的方式。

- 注意事项

	- 当一个java文件中，没有package关键字定义类所在包时，类所属的包时默认包

### import关键字

我们可以在不同的包中，定义同名类，在Java语言中，仅凭类名我们时无法唯一确定一个类。所以引入全限定类名，来唯一确定类。

在类名前面加上类所属的包名，中间用句点“.”分隔，称为类的完全限定名(Full Qualified Name)，简称类的限定名。

- 使用import声明，为编译器提供该类的定义信息 

	- 在同一个包下找到了类，则默认使用该类
	- 一旦用import声明了另一个包下同名的类，则使用那个类

- 作用

	- 当在类体中使用了与当前类不同包的类名时，编译器编译时因为无法找到该类的定义而失败
	
- 语法：`import <类的完全限定名>;`类的全限定名是指包名+类名，在java语言中，包名+类名才能唯一确定一个类
	- import声明提供了一种包的智能导入方式：`import <包名>.*;`
    - 包中的类将根据需要导入，避免使用多条import声明
	- 按需导入：只会导入当前包中没有的类

- 注意事项

	- import声明一般紧跟在package声明之后，必须在类声明之前
	- Java语言核心包java.lang包中的类将被隐式导入，可以直接使用其中的类 
	- 可以使用import <包名>.*；一次导入一个包下的多个类 ，但是这种方式不会自动嵌套导入子包中的类