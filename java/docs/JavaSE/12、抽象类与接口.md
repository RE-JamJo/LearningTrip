## 抽象类

### 概念

抽象类是包含有抽象方法的类或被abstract修饰的类 

### 注意事项

- 抽象类和抽象方法必须用abstract关键字修饰  

	- abstract class 类名 {} 
	- public abstract void eat(); 

- 抽象类不一定有抽象方法，有抽象方法的类一定是抽象类 

- 抽象类不能直接实例化 ，只能间接实例化

    - `抽象类类型 引用变量 = new 抽象子类;`抽象类引用指向抽象子类，再在子类当中实现相应方法(利用抽象类引用，访问抽象类中定义的行为)。

- 抽象类的子类可以是抽象类，也可以是具体类(当子类是具体类时，必须实现父类中所有的抽象方法) 。

### 抽象类的组成特征

- 成员变量：同普通类

- 构造方法

	- 和普通类相同
	- 抽象类不能直接实例化，还有构造方法的原因：1.抽象类中可以定义成员变量；2.为了能使得子类方便初始化抽象父类中成员变量的值。

- 成员方法：既可以有抽象方法，也可以有非抽象方法（主要用来代码复用）

- 和abstract冲突的关键字
	- private
	- static
	- final

abstract定义抽象方法，对于抽象方法而言，如果代码中要使用，其实永远是通过多态，调用的是子类中覆盖实现的抽象父类的抽象方法。
而被private，final，static修饰符修饰的方法，都不能再子类中被覆盖，于是意味着这些方法，无法在程序中运行。


## 接口

### 概念

- 表示一组特殊功能的集合(往往只包含这组特殊功能的声明)
- 由于单重继承的限制，使用接口来表示一组特殊集合
- 在java语言中，接口interface和类处于同等地位都表示数据类型
- 类和接口的对比

    - 类定义了一个数据集合(成员变量)和基于这个数据集合的一组操作(成员方法)，操作之间有一定联系(操作同一个数据集合)
    - 接口中通常只包含方法声明，即接口中的方法都是抽象方法(jdk8之前)
    - 接口中声明的方法，就纯粹表示一组功能的集合，功能相互之间可以没有啥联系，比较松散

### 语法

- 接口用关键字interface表示 
- 格式：`interface 接口名 {}` 

### 类和接口的关系

- 类可以实现接口，类实现接口用implements表示 
- 实现关系，其实是一种实质性的继承关系

### 接口特征

- 接口不能直接实例化，只能间接实例化
- 接口的子类，可以是抽象类也可以是具体类 (具体类必须实现接口中的所有抽象方法)

### 接口的组成特征

- 无构造方法
- 只能是常量，默认修饰符public static final，`接口名.`的方式访问
- 成员方法：只能是抽象方法，默认修饰符public abstract (jdk8之前)

### 接口实现了java语言的多重继承

- 接口与接口之间可以是多重继承
- 一个类可以在继承另一个类的情况下，实现多个接口(实现关系，也是一种实质上的继承关系)

### 抽象类 VS 接口

- 成员变量

    - 抽象类的成员变量，可以是变量可以是常量
    - 而接口中的成员变量，只能是常量

- 成员方法

    - 抽象类的成员方法，可以是抽象方法，也可以是非抽象方法
    - 接口中的成员方法，只能是抽象方法(jdk8之前)


- 类与抽象类

    - 继承关系，而且是单重继承

- 类与接口

    - 实现关系，一个类可以实现多个接口

- 接口与接口

    - 继承关系，接口与接口之间可以实现多重继承

- 设计理念的区别

	- 抽象类 被继承体现的是：”is a”的关系。共性功能(抽象类中定义的是大家共有的特性，共享的成员)

	- 接口 被实现体现的是："like a”的关系。扩展功能(表示功能的集合)

### JDK8中引入的特殊方法

- default默认方法

	- 在接口中定义的非静态的可以有方法体的方法，而且在接口中添加默认方法，不会影响实现接口的子类，并可以在子类中调用

	- 默认方法存在的意义是一种折中，向类中添加默认方法不会影响那些之前已经实现的方法

- static静态方法

	- 接口中定义的，可以有方法体的静态方法，只能在定义静态方法的接口或者通过定义接口的接口名.静态方法()的方式访问

	- 静态方法存在的意义类似于我们之前的工具方法

