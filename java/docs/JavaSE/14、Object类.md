# Object类

从现在开始，学习就不是以前那种学习方式了，要开始看jdk源码学习了，很多类的API(方法)都是需要我们自己去看源码了解其如何实现的。

最后要形成总结，以及串联起来。

## 定义
类Object是类层次结构的根类。即Object类是java中所有类，或直接或间接的父类。

## 成员变量
Object类没有成员变量。

## 构造方法
因为没有成员变量，只有默认无参构造方法。

## 成员方法

### 获取
- Class<?> getClass() 
    - 返回此 Object 的运行时类。
    - Class Jdk定义的一个类，每一个 Class 类的对象，都代表了一个运行时类
	- jvm每加载一个类，就会自动创建一个和该类对应的Class对象，该Class对象中包含的内容，和类定义信息。
	- 同时，一个类和一个Class对象，是一一对应的关系，即一个类只唯一对应一个class对象
	- 所以一个类和一个Class对象内容等价，又是一一对应关系，一个Class对象表示一个类。
    - 即每一个类中1.构造方法 2.成员变量 3.成员方法等等把这些共性抽取出来 ，形成Class类。

- String toString() 
    - 返回该对象的字符串表示。
    - 通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。**建议所有子类都重写此方法**。（因为不同的子类需要满足各自的需求时，必须重写该方法才能实现）
    - 对象的字符串表示：将对象中的成员变量的值拼接成一个字符串，以字符串形式表示
    - 源码中默认实现`getClass().getName() + '@' + Integer.toHexString(hashCode())`
    - 注意事项：当我们直接输出一个对象，输出的内容是该对象的字符串表示，其实就是toString方法返回的字符串；当对象和字符串作拼接，其实执行的是字符串，和对象的字符串(toString返回的字符串)拼接。
- protected Object clone() 
    - 创建并返回此对象的一个副本。
    - Object的clone方法（浅拷贝）：1、在堆上开辟空间创建对象。2、将原对象中每一个成员值，对应复制到复制对象中。3、但是，对于引用类型的成员变量，仅仅只复制了引用变量的地址，而并未复制引用变量所指向的变量
	- Object的clone方法实现的并不是一种完全的复制，称为浅拷贝。
    - 如何实现深拷贝？思路：1、利用浅拷贝，实现对原对象本身的复制；2、修改引用类型的成员变量值，让它指向原对象引用变量所指向的对象的副本。
    - 浅拷贝，只复制原对象中引用变量本身的值；深拷贝，复制的是原对象中引用变量指向的对象
    - 使用clone方法遇到的问题：CloneNotSupportedException（clone权限问题）。调用clone的对象，所属的类必须实现Cloneable接口。

- int hashCode() 
    - 返回该对象的哈希码值。
    - hash映射，最理想的情况，是能够实现一种一一映射。
    - hashCode方法是jdk提供的一种映射方法，会针对不同的对象返回不同的整数；这一般是通过将该对象的内部地址转换成一个整数来实现的（源码）。

### 判断
- boolean equals(Object obj) 
    - 指示其他某个对象是否与此对象“相等”。

- 什么是对象相等？
	- 仍然从对象的差异性角度理解，**同一个类**的对象之所以产生**差异**，这个差异来源于成员变量的**取值不同**。
    - 如果说，两个对象，是**不同类的对象**，我们认为这两个对象**一定不相等**。
	- 所以我们认为，**同一个类**的对象，当他们对应成员变量的**值都相等**，我们认为两个对象相等

- 其实，equals方法的效果，等价于指向对象的引用变量的地址值，也就是和==符号一致
- **如果需要比较对象的内容是否相等，需要在子类中覆盖Object的equals方法。**

### 回收
- protected void finalize() 
    - 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。
    - 该不重要，知道即可。


### 多线程相关
- void notify() 
    - 唤醒在此对象监视器上等待的单个线程。
- void notifyAll() 
    - 唤醒在此对象监视器上等待的所有线程。
- void wait() 
    - 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。
- void wait(long timeout) 
    - 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。 
- void wait(long timeout, int nanos) 
    - 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。 
